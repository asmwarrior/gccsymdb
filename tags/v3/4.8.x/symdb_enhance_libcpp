Index: gcc/libcpp/include/cpplib.h
===================================================================
--- gcc.orig/libcpp/include/cpplib.h	2012-07-25 10:57:16.749438416 +0800
+++ gcc/libcpp/include/cpplib.h	2012-07-25 10:57:31.210675501 +0800
@@ -526,6 +526,23 @@
      be expanded.  */
   cpp_hashnode * (*macro_to_expand) (cpp_reader *, const cpp_token *);
 
+  /* The more powerful function extracts token than cpp_get_token. Later
+   * callbacks show it. */
+  void (*lex_token) (cpp_reader *, const cpp_token*);
+  /* The pair is called when gcc expands macro. Enable lex_token in
+   * macro_start_expand, you can catch all macro tokens. The pair can be called
+   * nested, and the second parameter of macro_end_expand notifies you whether
+   * macro is still expanding. */
+  void (*macro_start_expand) (cpp_reader *, const cpp_token *,
+		  const cpp_hashnode *);
+  void (*macro_end_expand) (cpp_reader *, bool);
+  /* The pair is called when cpp directive (starting from `#', such as
+   * `#define M', `#endif' etc) is encountered and reaches end. When enable
+   * lex_token in start_directive, the sequence is lex_token("define"),
+   * lex_token("M") ... */
+  void (*start_directive) (cpp_reader *);
+  void (*end_directive) (cpp_reader *);
+
   /* Called to emit a diagnostic.  This callback receives the
      translated message.  */
   bool (*error) (cpp_reader *, int, int, source_location, unsigned int,
Index: gcc/libcpp/macro.c
===================================================================
--- gcc.orig/libcpp/macro.c	2012-07-25 10:57:16.750427468 +0800
+++ gcc/libcpp/macro.c	2012-07-25 10:57:31.213676714 +0800
@@ -148,7 +148,7 @@
 static void replace_args (cpp_reader *, cpp_hashnode *, cpp_macro *,
 			  macro_arg *, source_location);
 static _cpp_buff *funlike_invocation_p (cpp_reader *, cpp_hashnode *,
-					_cpp_buff **, unsigned *);
+					_cpp_buff **, unsigned *, const cpp_token *);
 static bool create_iso_definition (cpp_reader *, cpp_macro *);
 
 /* #define directive parsing and handling.  */
@@ -963,7 +963,8 @@
    returned buffer.  */
 static _cpp_buff *
 funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node,
-		      _cpp_buff **pragma_buff, unsigned *num_args)
+		      _cpp_buff **pragma_buff, unsigned *num_args,
+		      const cpp_token *head)
 {
   const cpp_token *token, *padding = NULL;
 
@@ -980,6 +981,8 @@
   if (token->type == CPP_OPEN_PAREN)
     {
       pfile->state.parsing_args = 2;
+      if (pfile->cb.macro_start_expand)
+        pfile->cb.macro_start_expand (pfile, head, node);
       return collect_args (pfile, node, pragma_buff, num_args);
     }
 
@@ -1064,7 +1067,7 @@
 	  pfile->keep_tokens++;
 	  pfile->state.parsing_args = 1;
 	  buff = funlike_invocation_p (pfile, node, &pragma_buff,
-				       &num_args);
+				       &num_args, result);
 	  pfile->state.parsing_args = 0;
 	  pfile->keep_tokens--;
 	  pfile->state.prevent_expansion--;
@@ -1110,6 +1113,8 @@
 
       if (macro->paramc == 0)
 	{
+      if (pfile->cb.macro_start_expand)
+        pfile->cb.macro_start_expand (pfile, result, node);
 	  if (CPP_OPTION (pfile, track_macro_expansion))
 	    {
 	      unsigned int i, count = macro->count;
@@ -2245,6 +2250,8 @@
   /* decrease peak memory consumption by feeing the context.  */
   pfile->context->next = NULL;
   free (context);
+  if (pfile->cb.macro_end_expand)
+    pfile->cb.macro_end_expand (pfile, in_macro_expansion_p (pfile));
 }
 
 /* Return TRUE if we reached the end of the set of tokens stored in
Index: gcc/libcpp/directives.c
===================================================================
--- gcc.orig/libcpp/directives.c	2012-07-25 10:57:16.750427468 +0800
+++ gcc/libcpp/directives.c	2012-07-25 10:57:31.215684360 +0800
@@ -275,6 +275,9 @@
 
   /* Some handlers need the position of the # for diagnostics.  */
   pfile->directive_line = pfile->line_table->highest_line;
+
+  if (pfile->cb.start_directive)
+    pfile->cb.start_directive (pfile);
 }
 
 /* Called when leaving a directive, _Pragma or command-line directive.  */
@@ -309,6 +312,9 @@
   pfile->state.in_expression = 0;
   pfile->state.angled_headers = 0;
   pfile->directive = 0;
+
+  if (pfile->cb.end_directive)
+    pfile->cb.end_directive (pfile);
 }
 
 /* Prepare to handle the directive in pfile->directive.  */
Index: gcc/libcpp/lex.c
===================================================================
--- gcc.orig/libcpp/lex.c	2012-07-25 10:25:36.000000000 +0800
+++ gcc/libcpp/lex.c	2012-07-25 10:58:27.736403438 +0800
@@ -1972,6 +1972,8 @@
 	}
       else
 	result = _cpp_lex_direct (pfile);
+    if (pfile->cb.lex_token)
+      pfile->cb.lex_token (pfile, result);
 
       if (result->flags & BOL)
 	{
