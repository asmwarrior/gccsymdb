Index: gcc-4.7.0/libcpp/directives.c
===================================================================
--- gcc-4.7.0.orig/libcpp/directives.c	2012-06-20 09:09:15.000000000 +0800
+++ gcc-4.7.0/libcpp/directives.c	2012-06-20 09:20:28.255421023 +0800
@@ -275,6 +275,9 @@
 
   /* Some handlers need the position of the # for diagnostics.  */
   pfile->directive_line = pfile->line_table->highest_line;
+
+  if (pfile->cb.start_directive)
+    pfile->cb.start_directive (pfile);
 }
 
 /* Called when leaving a directive, _Pragma or command-line directive.  */
@@ -309,6 +312,9 @@
   pfile->state.in_expression = 0;
   pfile->state.angled_headers = 0;
   pfile->directive = 0;
+
+  if (pfile->cb.end_directive)
+    pfile->cb.end_directive (pfile);
 }
 
 /* Prepare to handle the directive in pfile->directive.  */
Index: gcc-4.7.0/libcpp/include/cpplib.h
===================================================================
--- gcc-4.7.0.orig/libcpp/include/cpplib.h	2012-06-20 09:09:15.000000000 +0800
+++ gcc-4.7.0/libcpp/include/cpplib.h	2012-06-20 09:22:34.645397048 +0800
@@ -522,6 +522,21 @@
      be expanded.  */
   cpp_hashnode * (*macro_to_expand) (cpp_reader *, const cpp_token *);
 
+  /* macro_{start/end}_expand are called when gcc starts to expand macro, note
+   * if A macro includes B macro, the pair is called multiple times. */
+  void (*macro_start_expand) (cpp_reader *, const cpp_token *,
+		  const cpp_hashnode *);
+  void (*macro_end_expand) (cpp_reader *);
+  /* Called when a function-like macro stops collecting macro parameters,
+   * cancel = true, macro expansion is canceled. */
+  void (*macro_end_arg) (cpp_reader *, bool cancel);
+  /* The pair is called when cpp directive (starting from `#', such as
+   * `#define', `#endif' etc) is encountered and reaches end. */
+  void (*start_directive) (cpp_reader *);
+  void (*end_directive) (cpp_reader *);
+  /* The more powerful function getting token than cpp_get_token. */
+  void (*lex_token) (cpp_reader *, const cpp_token*);
+
   /* Called to emit a diagnostic.  This callback receives the
      translated message.  */
   bool (*error) (cpp_reader *, int, int, source_location, unsigned int,
Index: gcc-4.7.0/libcpp/lex.c
===================================================================
--- gcc-4.7.0.orig/libcpp/lex.c	2012-06-20 09:09:15.000000000 +0800
+++ gcc-4.7.0/libcpp/lex.c	2012-06-20 09:20:28.257424329 +0800
@@ -1875,6 +1875,8 @@
 	}
       else
 	result = _cpp_lex_direct (pfile);
+    if (pfile->cb.lex_token)
+      pfile->cb.lex_token (pfile, result);
 
       if (result->flags & BOL)
 	{
Index: gcc-4.7.0/libcpp/macro.c
===================================================================
--- gcc-4.7.0.orig/libcpp/macro.c	2012-06-20 09:09:15.000000000 +0800
+++ gcc-4.7.0/libcpp/macro.c	2012-06-20 09:20:28.260424425 +0800
@@ -1015,6 +1015,8 @@
 	  pfile->state.parsing_args = 1;
 	  buff = funlike_invocation_p (pfile, node, &pragma_buff,
 				       &num_args);
+	  if (pfile->cb.macro_end_arg)
+	    pfile->cb.macro_end_arg (pfile, buff == NULL);
 	  pfile->state.parsing_args = 0;
 	  pfile->keep_tokens--;
 	  pfile->state.prevent_expansion--;
@@ -2263,6 +2265,8 @@
 	  if (pfile->context->c.macro)
 	    ++num_expanded_macros_counter;
 	  _cpp_pop_context (pfile);
+	  if (pfile->cb.macro_end_expand)
+	    pfile->cb.macro_end_expand (pfile);
 	  if (pfile->state.in_directive)
 	    continue;
 	  result = &pfile->avoid_paste;
@@ -2321,8 +2325,14 @@
 		}
 	    }
 	  else
-	    ret = enter_macro_context (pfile, node, result, 
-				       virt_loc);
+ 	    {
+	      if (pfile->cb.macro_start_expand)
+		pfile->cb.macro_start_expand (pfile, result, node);
+	  ret = enter_macro_context (pfile, node, result, virt_loc);
+    if (ret == 0 && pfile->cb.macro_end_expand)
+      /* macro expansion is canceled. */
+      pfile->cb.macro_end_expand (pfile);
+	    }
 	  if (ret)
  	    {
 	      if (pfile->state.in_directive || ret == 2)
