Index: gcc-4.6.2/gcc/plugin.def
===================================================================
--- gcc-4.6.2.orig/gcc/plugin.def	2012-01-08 17:21:36.000000000 +0800
+++ gcc-4.6.2/gcc/plugin.def	2012-01-08 17:25:06.000000000 +0800
@@ -89,6 +89,12 @@
 /* Called when a pass is first instantiated.  */
 DEFEVENT (PLUGIN_NEW_PASS)
 
+/* Called when a cpp token is extracted.  */
+DEFEVENT (PLUGIN_CPP_TOKEN)
+
+/* Called when a c token is extracted.  */
+DEFEVENT (PLUGIN_C_TOKEN)
+
 /* After the hard-coded events above, plugins can dynamically allocate events
    at run time.
    PLUGIN_EVENT_FIRST_DYNAMIC only appears as last enum element.  */
Index: gcc-4.6.2/gcc/c-family/c-lex.c
===================================================================
--- gcc-4.6.2.orig/gcc/c-family/c-lex.c	2011-01-27 04:06:57.000000000 +0800
+++ gcc-4.6.2/gcc/c-family/c-lex.c	2012-01-08 17:25:06.000000000 +0800
@@ -36,6 +36,7 @@
 #include "splay-tree.h"
 #include "debug.h"
 #include "target.h"
+#include "plugin.h"
 
 /* We may keep statistics about how long which files took to compile.  */
 static int header_time, body_time;
@@ -296,10 +297,13 @@
   const cpp_token *tok;
   enum cpp_ttype type;
   unsigned char add_flags = 0;
+  void *plugin_tok;
 
   timevar_push (TV_CPP);
  retry:
   tok = cpp_get_token_with_location (parse_in, loc);
+  plugin_tok = &tok;
+  invoke_plugin_callbacks (PLUGIN_CPP_TOKEN, *(cpp_token **) plugin_tok);
   type = tok->type;
 
  retry_after_at:
Index: gcc-4.6.2/gcc/c-parser.c
===================================================================
--- gcc-4.6.2.orig/gcc/c-parser.c	2012-01-08 17:21:36.000000000 +0800
+++ gcc-4.6.2/gcc/c-parser.c	2012-01-08 17:29:49.000000000 +0800
@@ -121,45 +121,6 @@
    C++).  It would then be possible to share more of the C and C++
    lexer code, if desired.  */
 
-/* The following local token type is used.  */
-
-/* A keyword.  */
-#define CPP_KEYWORD ((enum cpp_ttype) (N_TTYPES + 1))
-
-/* More information about the type of a CPP_NAME token.  */
-typedef enum c_id_kind {
-  /* An ordinary identifier.  */
-  C_ID_ID,
-  /* An identifier declared as a typedef name.  */
-  C_ID_TYPENAME,
-  /* An identifier declared as an Objective-C class name.  */
-  C_ID_CLASSNAME,
-  /* An address space identifier.  */
-  C_ID_ADDRSPACE,
-  /* Not an identifier.  */
-  C_ID_NONE
-} c_id_kind;
-
-/* A single C token after string literal concatenation and conversion
-   of preprocessing tokens to tokens.  */
-typedef struct GTY (()) c_token {
-  /* The kind of token.  */
-  ENUM_BITFIELD (cpp_ttype) type : 8;
-  /* If this token is a CPP_NAME, this value indicates whether also
-     declared as some kind of type.  Otherwise, it is C_ID_NONE.  */
-  ENUM_BITFIELD (c_id_kind) id_kind : 8;
-  /* If this token is a keyword, this value indicates which keyword.
-     Otherwise, this value is RID_MAX.  */
-  ENUM_BITFIELD (rid) keyword : 8;
-  /* If this token is a CPP_PRAGMA, this indicates the pragma that
-     was seen.  Otherwise it is PRAGMA_NONE.  */
-  ENUM_BITFIELD (pragma_kind) pragma_kind : 8;
-  /* The location at which this token was found.  */
-  location_t location;
-  /* The value associated with this token, if any.  */
-  tree value;
-} c_token;
-
 /* A parser structure recording information about the state and
    context of parsing.  Includes lexer information with up to two
    tokens of look-ahead; more are not needed for C.  */
@@ -386,6 +347,7 @@
       break;
     }
   timevar_pop (TV_LEX);
+  invoke_plugin_callbacks (PLUGIN_C_TOKEN, token);
 }
 
 /* Return a pointer to the next token from PARSER, reading it in if
Index: gcc-4.6.2/gcc/plugin.c
===================================================================
--- gcc-4.6.2.orig/gcc/plugin.c	2012-01-08 17:21:36.000000000 +0800
+++ gcc-4.6.2/gcc/plugin.c	2012-01-08 17:25:06.000000000 +0800
@@ -438,6 +438,8 @@
       case PLUGIN_EARLY_GIMPLE_PASSES_START:
       case PLUGIN_EARLY_GIMPLE_PASSES_END:
       case PLUGIN_NEW_PASS:
+      case PLUGIN_CPP_TOKEN:
+      case PLUGIN_C_TOKEN:
         {
           struct callback_info *new_callback;
           if (!callback)
@@ -514,6 +516,8 @@
       case PLUGIN_EARLY_GIMPLE_PASSES_START:
       case PLUGIN_EARLY_GIMPLE_PASSES_END:
       case PLUGIN_NEW_PASS:
+      case PLUGIN_CPP_TOKEN:
+      case PLUGIN_C_TOKEN:
         {
           /* Iterate over every callback registered with this event and
              call it.  */
Index: gcc-4.6.2/gcc/doc/plugins.texi
===================================================================
--- gcc-4.6.2.orig/gcc/doc/plugins.texi	2012-01-08 17:21:36.000000000 +0800
+++ gcc-4.6.2/gcc/doc/plugins.texi	2012-01-08 17:25:06.000000000 +0800
@@ -183,6 +183,8 @@
   PLUGIN_EARLY_GIMPLE_PASSES_END,
   /* Called when a pass is first instantiated.  */
   PLUGIN_NEW_PASS,
+  PLUGIN_CPP_TOKEN,                /* Called when GCC gets a cpp token. */
+  PLUGIN_C_TOKEN,                  /* Called when GCC gets a c token. */
 
   PLUGIN_EVENT_FIRST_DYNAMIC    /* Dummy event used for indexing callback
                                    array.  */
Index: gcc-4.6.2/gcc/c-family/c-common.h
===================================================================
--- gcc-4.6.2.orig/gcc/c-family/c-common.h	2011-02-04 01:16:17.000000000 +0800
+++ gcc-4.6.2/gcc/c-family/c-common.h	2012-01-08 17:25:06.000000000 +0800
@@ -25,6 +25,7 @@
 #include "splay-tree.h"
 #include "cpplib.h"
 #include "ggc.h"
+#include "c-pragma.h"
 
 /* In order for the format checking to accept the C frontend
    diagnostic framework extensions, you must include this file before
@@ -1007,4 +1008,43 @@
 extern tree c_omp_remap_decl (tree, bool);
 extern void record_types_used_by_current_var_decl (tree);
 
+/* The following local token type is used.  */
+
+/* A keyword.  */
+#define CPP_KEYWORD ((enum cpp_ttype) (N_TTYPES + 1))
+
+/* More information about the type of a CPP_NAME token.  */
+typedef enum c_id_kind {
+  /* An ordinary identifier.  */
+  C_ID_ID,
+  /* An identifier declared as a typedef name.  */
+  C_ID_TYPENAME,
+  /* An identifier declared as an Objective-C class name.  */
+  C_ID_CLASSNAME,
+  /* An address space identifier.  */
+  C_ID_ADDRSPACE,
+  /* Not an identifier.  */
+  C_ID_NONE
+} c_id_kind;
+
+/* A single C token after string literal concatenation and conversion
+   of preprocessing tokens to tokens.  */
+typedef struct GTY (()) c_token {
+  /* The kind of token.  */
+  ENUM_BITFIELD (cpp_ttype) type : 8;
+  /* If this token is a CPP_NAME, this value indicates whether also
+     declared as some kind of type.  Otherwise, it is C_ID_NONE.  */
+  ENUM_BITFIELD (c_id_kind) id_kind : 8;
+  /* If this token is a keyword, this value indicates which keyword.
+     Otherwise, this value is RID_MAX.  */
+  ENUM_BITFIELD (rid) keyword : 8;
+  /* If this token is a CPP_PRAGMA, this indicates the pragma that
+     was seen.  Otherwise it is PRAGMA_NONE.  */
+  ENUM_BITFIELD (pragma_kind) pragma_kind : 8;
+  /* The value associated with this token, if any.  */
+  tree value;
+  /* The location at which this token was found.  */
+  location_t location;
+} c_token;
+
 #endif /* ! GCC_C_COMMON_H */
