Index: gcc/gcc/plugin.def
===================================================================
--- gcc.orig/gcc/plugin.def	2012-07-23 10:48:16.357563216 +0800
+++ gcc/gcc/plugin.def	2012-07-23 10:48:21.318550696 +0800
@@ -92,6 +92,34 @@
 /* Called when a pass is first instantiated.  */
 DEFEVENT (PLUGIN_NEW_PASS)
 
+/* Called when a cpp token is extracted.  */
+DEFEVENT (PLUGIN_CPP_TOKEN)
+
+/* Called when a c token is extracted.  */
+DEFEVENT (PLUGIN_C_TOKEN)
+
+/* An extern declaration (file-scope) is encounted. */
+DEFEVENT (PLUGIN_EXTERN_DECL)
+
+/* Cooperate PLUGIN_EXTERN_FUNC to parse a function with old-style parameter
+ * declaration. */
+DEFEVENT (PLUGIN_EXTERN_FUNC_OLD_PARAM)
+
+/* Called when an extern function definition is parsed. */
+DEFEVENT (PLUGIN_EXTERN_FUNC)
+
+/* Called when an extern variable definition is parsed. */
+DEFEVENT (PLUGIN_EXTERN_VAR)
+
+/* An extern declaration specifier definition is parsed. */
+DEFEVENT (PLUGIN_EXTERN_DECLSPECS)
+
+/* A function is called. */
+DEFEVENT (PLUGIN_CALL_FUNCTION)
+
+/* Called when an enumerator is parsed. */
+DEFEVENT (PLUGIN_ENUMERATOR)
+
 /* After the hard-coded events above, plugins can dynamically allocate events
    at run time.
    PLUGIN_EVENT_FIRST_DYNAMIC only appears as last enum element.  */
Index: gcc/gcc/c-family/c-lex.c
===================================================================
--- gcc.orig/gcc/c-family/c-lex.c	2012-07-23 10:48:16.357563216 +0800
+++ gcc/gcc/c-family/c-lex.c	2012-07-23 10:48:21.319552036 +0800
@@ -35,6 +35,7 @@
 #include "splay-tree.h"
 #include "debug.h"
 #include "target.h"
+#include "plugin.h"
 
 /* We may keep statistics about how long which files took to compile.  */
 static int header_time, body_time;
@@ -379,6 +380,7 @@
 	    case CPP_STRING32:
 	    case CPP_UTF8STRING:
 	      type = lex_string (tok, value, true, true);
+		  tok = NULL;
 	      break;
 
 	    case CPP_NAME:
@@ -480,6 +482,7 @@
 	{
 	  type = lex_string (tok, value, false,
 			     (lex_flags & C_LEX_STRING_NO_TRANSLATE) == 0);
+	  tok = NULL;
 	  break;
 	}
       *value = build_string (tok->val.str.len, (const char *) tok->val.str.text);
@@ -514,6 +517,7 @@
     }
 
   timevar_pop (TV_CPP);
+  invoke_plugin_callbacks (PLUGIN_CPP_TOKEN, tok);
 
   return type;
 }
Index: gcc/gcc/plugin.c
===================================================================
--- gcc.orig/gcc/plugin.c	2012-07-23 10:48:16.357563216 +0800
+++ gcc/gcc/plugin.c	2012-07-23 10:48:21.326412675 +0800
@@ -438,6 +438,15 @@
       case PLUGIN_EARLY_GIMPLE_PASSES_START:
       case PLUGIN_EARLY_GIMPLE_PASSES_END:
       case PLUGIN_NEW_PASS:
+      case PLUGIN_CPP_TOKEN:
+      case PLUGIN_C_TOKEN:
+      case PLUGIN_EXTERN_DECL:
+      case PLUGIN_EXTERN_FUNC_OLD_PARAM:
+      case PLUGIN_EXTERN_FUNC:
+      case PLUGIN_EXTERN_VAR:
+      case PLUGIN_EXTERN_DECLSPECS:
+      case PLUGIN_CALL_FUNCTION:
+      case PLUGIN_ENUMERATOR:
         {
           struct callback_info *new_callback;
           if (!callback)
@@ -515,6 +524,15 @@
       case PLUGIN_EARLY_GIMPLE_PASSES_START:
       case PLUGIN_EARLY_GIMPLE_PASSES_END:
       case PLUGIN_NEW_PASS:
+      case PLUGIN_CPP_TOKEN:
+      case PLUGIN_C_TOKEN:
+      case PLUGIN_EXTERN_DECL:
+      case PLUGIN_EXTERN_FUNC_OLD_PARAM:
+      case PLUGIN_EXTERN_FUNC:
+      case PLUGIN_EXTERN_VAR:
+      case PLUGIN_EXTERN_DECLSPECS:
+      case PLUGIN_CALL_FUNCTION:
+      case PLUGIN_ENUMERATOR:
         {
           /* Iterate over every callback registered with this event and
              call it.  */
Index: gcc/gcc/doc/plugins.texi
===================================================================
--- gcc.orig/gcc/doc/plugins.texi	2012-07-23 10:48:16.357563216 +0800
+++ gcc/gcc/doc/plugins.texi	2012-07-23 10:48:21.335549902 +0800
@@ -184,6 +184,23 @@
   PLUGIN_EARLY_GIMPLE_PASSES_END,
   /* Called when a pass is first instantiated.  */
   PLUGIN_NEW_PASS,
+  PLUGIN_CPP_TOKEN,                /* Called when GCC gets a cpp token. */
+  PLUGIN_C_TOKEN,                  /* Called when GCC gets a c token. */
+  /* An extern declaration (file-scope) is encounted. */
+  PLUGIN_EXTERN_DECL,
+  /* Cooperate PLUGIN_EXTERN_FUNC to parse a function with old-style parameter
+   * declaration. */
+  PLUGIN_EXTERN_FUNC_OLD_PARAM,
+  /* An extern function definition is parsed. */
+  PLUGIN_EXTERN_FUNC,
+  /* An extern variable definition is parsed. */
+  PLUGIN_EXTERN_VAR,
+  /* An extern declaration specifier definition is parsed. */
+  PLUGIN_EXTERN_DECLSPECS,
+  /* A function is called. */
+  PLUGIN_CALL_FUNCTION,
+  /* An enumerator is parsed. */
+  PLUGIN_ENUMERATOR,
 
   PLUGIN_EVENT_FIRST_DYNAMIC    /* Dummy event used for indexing callback
                                    array.  */
Index: gcc/gcc/c/c-parser.c
===================================================================
--- gcc.orig/gcc/c/c-parser.c	2012-07-23 10:48:16.357563216 +0800
+++ gcc/gcc/c/c-parser.c	2012-07-23 10:48:21.341550547 +0800
@@ -387,6 +387,7 @@
       break;
     }
   timevar_pop (TV_LEX);
+  invoke_plugin_callbacks (PLUGIN_C_TOKEN, token);
 }
 
 /* Return a pointer to the next token from PARSER, reading it in if
@@ -1359,6 +1360,7 @@
 	 an @interface or @protocol with prefix attributes).  We can
 	 only tell which after parsing the declaration specifiers, if
 	 any, and the first declarator.  */
+      invoke_plugin_callbacks (PLUGIN_EXTERN_DECL, NULL);
       c_parser_declaration_or_fndef (parser, true, true, true, false, true, NULL);
       break;
     }
@@ -1487,6 +1489,11 @@
       return;
     }
   finish_declspecs (specs);
+  {
+    void* pair[2]; pair[0] = specs; pair[1] = (void*) parser->tokens_avail;
+    if (!nested)
+      invoke_plugin_callbacks (PLUGIN_EXTERN_DECLSPECS, pair);
+  }
   if (c_parser_next_token_is (parser, CPP_SEMICOLON))
     {
       if (empty_ok)
@@ -1621,6 +1628,11 @@
 	{
 	  tree asm_name = NULL_TREE;
 	  tree postfix_attrs = NULL_TREE;
+	  {
+	    void* pair[2]; pair[0] = specs; pair[1] = declarator;
+        if (!nested)
+          invoke_plugin_callbacks (PLUGIN_EXTERN_VAR, pair);
+	  }
 	  if (!diagnosed_no_specs && !specs->declspecs_seen_p)
 	    {
 	      diagnosed_no_specs = true;
@@ -1747,11 +1759,15 @@
 	 declarator with a nonempty identifier list in a definition;
 	 and postfix attributes have never been accepted here in
 	 function definitions either.  */
+      if (!nested)
+        invoke_plugin_callbacks (PLUGIN_EXTERN_FUNC_OLD_PARAM, NULL);
       while (c_parser_next_token_is_not (parser, CPP_EOF)
 	     && c_parser_next_token_is_not (parser, CPP_OPEN_BRACE))
 	c_parser_declaration_or_fndef (parser, false, false, false,
 				       true, false, NULL);
       store_parm_decls ();
+      if (!nested)
+        invoke_plugin_callbacks (PLUGIN_EXTERN_FUNC, declarator);
       DECL_STRUCT_FUNCTION (current_function_decl)->function_start_locus
 	= c_parser_peek_token (parser)->location;
       fnbody = c_parser_compound_statement (parser);
@@ -2267,6 +2283,7 @@
 	    }
 	  token = c_parser_peek_token (parser);
 	  enum_id = token->value;
+      invoke_plugin_callbacks (PLUGIN_ENUMERATOR, enum_id);
 	  /* Set the location in case we create a decl now.  */
 	  c_parser_set_source_position_from_token (token);
 	  decl_loc = value_loc = token->location;
@@ -6876,6 +6893,7 @@
 	  break;
 	case CPP_OPEN_PAREN:
 	  /* Function call.  */
+      invoke_plugin_callbacks (PLUGIN_CALL_FUNCTION, expr.value);
 	  c_parser_consume_token (parser);
 	  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
 	    exprlist = NULL;
