Index: gcc/libcpp/include/cpplib.h
===================================================================
--- gcc.orig/libcpp/include/cpplib.h
+++ gcc/libcpp/include/cpplib.h
@@ -207,10 +207,10 @@ struct GTY(()) cpp_identifier {
        node;
 };
 
-/* A preprocessing token.  This has been carefully packed and should
-   occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */
+/* A preprocessing token. */
 struct GTY(()) cpp_token {
   source_location src_loc;	/* Location of first char of token.  */
+  int file_offset;
   ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */
   unsigned short flags;		/* flags - see above */
 
@@ -495,6 +495,29 @@ struct cpp_callbacks
      be expanded.  */
   cpp_hashnode * (*macro_to_expand) (cpp_reader *, const cpp_token *);
 
+  /* macro_{start/end}_expand are called when gcc starts to expand macro, note
+   * if A macro includes B macro, the pair is called multiple times. */
+  void (*macro_start_expand) (cpp_reader *, const cpp_token *,
+		  const cpp_hashnode *);
+  void (*macro_end_expand) (cpp_reader *);
+  /* Called when a function-like macro stops collecting macro parameters,
+   * cancel = true, macro expansion is canceled. */
+  void (*macro_end_arg) (cpp_reader *, bool cancel);
+  /* Used to collect intern data of gcc macro expansion, normally they are
+   * invisible to user. */
+  void (*macro_intern_expand) (cpp_reader *, void*, int, bool);
+  /* Called to collect comment. */
+  void (*comment) (cpp_reader *, const cpp_token*);
+  /* The pair is called when cpp directive (starting from `#', such as
+   * `#define', `#endif' etc) is encountered and reaches end. */
+  void (*start_directive) (cpp_reader *, const cpp_token*);
+  void (*end_directive) (cpp_reader *);
+  /* The more powerful function getting token than cpp_get_token. Here, name
+   * directive_token maybe makes you confused, it's named from
+   * libcpp/lex.c:_cpp_lex_direct, there isn't relationship between
+   * directive_token and {start, end}_directive above. */
+  void (*directive_token) (cpp_reader *, const cpp_token*);
+
   /* Called to emit a diagnostic.  This callback receives the
      translated message.  */
   bool (*error) (cpp_reader *, int, source_location, unsigned int,
Index: gcc/libcpp/lex.c
===================================================================
--- gcc.orig/libcpp/lex.c
+++ gcc/libcpp/lex.c
@@ -51,7 +51,8 @@ static const struct token_spelling token
 #define TOKEN_SPELL(token) (token_spellings[(token)->type].category)
 #define TOKEN_NAME(token) (token_spellings[(token)->type].name)
 
-static void add_line_note (cpp_buffer *, const uchar *, unsigned int);
+static void add_line_note (cpp_buffer *, const uchar *, unsigned int,
+			   const uchar *);
 static int skip_line_comment (cpp_reader *);
 static void skip_whitespace (cpp_reader *, cppchar_t);
 static void lex_string (cpp_reader *, cpp_token *, const uchar *);
@@ -82,7 +83,8 @@ cpp_ideq (const cpp_token *token, const 
 /* Record a note TYPE at byte POS into the current cleaned logical
    line.  */
 static void
-add_line_note (cpp_buffer *buffer, const uchar *pos, unsigned int type)
+add_line_note (cpp_buffer *buffer, const uchar *pos, unsigned int type,
+	       const uchar * offset)
 {
   if (buffer->notes_used == buffer->notes_cap)
     {
@@ -93,6 +95,7 @@ add_line_note (cpp_buffer *buffer, const
 
   buffer->notes[buffer->notes_used].pos = pos;
   buffer->notes[buffer->notes_used].type = type;
+  buffer->notes[buffer->notes_used].adjust_offset = offset;
   buffer->notes_used++;
 }
 
@@ -150,7 +153,7 @@ _cpp_clean_line (cpp_reader *pfile)
 
 	      /* Have an escaped newline; process it and proceed to
 		 the slow path.  */
-	      add_line_note (buffer, p - 1, p != d ? ' ' : '\\');
+	      add_line_note (buffer, p - 1, p != d ? ' ' : '\\', s + 1);
 	      d = p - 2;
 	      buffer->next_line = p - 1;
 	      break;
@@ -163,7 +166,7 @@ _cpp_clean_line (cpp_reader *pfile)
 	    {
 	      /* Have a trigraph.  We may or may not have to convert
 		 it.  Add a line note regardless, for -Wtrigraphs.  */
-	      add_line_note (buffer, s, s[2]);
+	      add_line_note (buffer, s, s[2], 0);
 	      if (CPP_OPTION (pfile, trigraphs))
 		{
 		  /* We do, and that means we have to switch to the
@@ -197,14 +200,14 @@ _cpp_clean_line (cpp_reader *pfile)
 	      if (p == buffer->next_line || p[-1] != '\\')
 		break;
 
-	      add_line_note (buffer, p - 1, p != d ? ' ': '\\');
+	      add_line_note (buffer, p - 1, p != d ? ' ': '\\', s + 1);
 	      d = p - 2;
 	      buffer->next_line = p - 1;
 	    }
 	  else if (c == '?' && s[1] == '?' && _cpp_trigraph_map[s[2]])
 	    {
 	      /* Add a note regardless, for the benefit of -Wtrigraphs.  */
-	      add_line_note (buffer, d, s[2]);
+	      add_line_note (buffer, d, s[2], 0);
 	      if (CPP_OPTION (pfile, trigraphs))
 		{
 		  *d = _cpp_trigraph_map[s[2]];
@@ -228,7 +231,7 @@ _cpp_clean_line (cpp_reader *pfile)
  done:
   *d = '\n';
   /* A sentinel note that should never be processed.  */
-  add_line_note (buffer, d + 1, '\n');
+  add_line_note (buffer, d + 1, '\n', s + 1);
   buffer->next_line = s + 1;
 }
 
@@ -1173,6 +1176,8 @@ _cpp_lex_token (cpp_reader *pfile)
 		 handles the directive as normal.  */
 	      && pfile->state.parsing_args != 1)
 	    {
+	      if (pfile->cb.start_directive)
+		pfile->cb.start_directive (pfile, result);
 	      if (_cpp_handle_directive (pfile, result->flags & PREV_WHITE))
 		{
 		  if (pfile->directive_result.type == CPP_PADDING)
@@ -1319,6 +1324,17 @@ _cpp_lex_direct (cpp_reader *pfile)
       _cpp_process_line_notes (pfile, false);
       result->src_loc = pfile->line_table->highest_line;
     }
+  if (buffer->cur_note != 0)
+    {
+      int index = buffer->cur_note - 1;
+      result->file_offset = buffer->cur - buffer->buf;
+      result->file_offset +=
+	buffer->notes[index].adjust_offset - buffer->notes[index].pos;
+    }
+  else
+    {
+      result->file_offset = buffer->cur - buffer->buf;
+    }
   c = *buffer->cur++;
 
   LINEMAP_POSITION_FOR_COLUMN (result->src_loc, pfile->line_table,
@@ -1444,12 +1460,18 @@ _cpp_lex_direct (cpp_reader *pfile)
 	  break;
 	}
 
+      if (pfile->cb.comment)
+	{
+	  save_comment (pfile, result, comment_start, c);
+	  pfile->cb.comment (pfile, result);
+	}
       if (!pfile->state.save_comments)
 	{
 	  result->flags |= PREV_WHITE;
 	  goto update_tokens_line;
 	}
 
+      if (!pfile->cb.comment)
       /* Save the comment as a token in its own right.  */
       save_comment (pfile, result, comment_start, c);
       break;
@@ -1628,6 +1650,8 @@ _cpp_lex_direct (cpp_reader *pfile)
       break;
     }
 
+  if (pfile->cb.directive_token)
+    pfile->cb.directive_token (pfile, result);
   return result;
 }
 
Index: gcc/libcpp/macro.c
===================================================================
--- gcc.orig/libcpp/macro.c
+++ gcc/libcpp/macro.c
@@ -848,10 +848,13 @@ enter_macro_context (cpp_reader *pfile, 
       if (macro->fun_like)
 	{
 	  _cpp_buff *buff;
+	  void *expanded_beg = NULL, *expanded_end;
 
 	  pfile->state.prevent_expansion++;
 	  pfile->keep_tokens++;
 	  pfile->state.parsing_args = 1;
+	  if (pfile->cb.macro_intern_expand)
+	    expanded_beg = (void *) FIRST (pfile->context).token;
 	  buff = funlike_invocation_p (pfile, node, &pragma_buff);
 	  pfile->state.parsing_args = 0;
 	  pfile->keep_tokens--;
@@ -867,9 +870,25 @@ enter_macro_context (cpp_reader *pfile, 
 	      if (pragma_buff)
 		_cpp_release_buff (pfile, pragma_buff);
 
+	      if (pfile->cb.macro_end_arg)
+		pfile->cb.macro_end_arg (pfile, true);
 	      return 0;
 	    }
+	  if (pfile->cb.macro_intern_expand)
+	    {
+	      cpp_context *context = pfile->context;
+	      expanded_end = (void *) FIRST (context).token;
+	      pfile->cb.macro_intern_expand (pfile, expanded_beg,
+					     context->direct_p ?
+					     (cpp_token *) expanded_end -
+					     (cpp_token *) expanded_beg
+					     : (cpp_token **) expanded_end -
+					     (cpp_token **) expanded_beg,
+					     context->direct_p);
+	    }
 
+	  if (pfile->cb.macro_end_arg)
+	    pfile->cb.macro_end_arg (pfile, false);
 	  if (macro->paramc > 0)
 	    replace_args (pfile, node, macro, (macro_arg *) buff->base);
 	  _cpp_release_buff (pfile, buff);
@@ -1254,6 +1273,8 @@ cpp_get_token (cpp_reader *pfile)
       else
 	{
 	  _cpp_pop_context (pfile);
+	  if (pfile->cb.macro_end_expand)
+	    pfile->cb.macro_end_expand (pfile);
 	  if (pfile->state.in_directive)
 	    continue;
 	  return &pfile->avoid_paste;
@@ -1310,7 +1331,14 @@ cpp_get_token (cpp_reader *pfile)
 		}
 	    }
 	  else
-	    ret = enter_macro_context (pfile, node, result);
+ 	    {
+	      if (pfile->cb.macro_start_expand)
+		pfile->cb.macro_start_expand (pfile, result, node);
+	  ret = enter_macro_context (pfile, node, result);
+    if (ret == 0 && pfile->cb.macro_end_expand)
+      /* macro expansion is canceled. */
+      pfile->cb.macro_end_expand (pfile);
+	    }
 	  if (ret)
  	    {
 	      if (pfile->state.in_directive || ret == 2)
Index: gcc/libcpp/directives.c
===================================================================
--- gcc.orig/libcpp/directives.c
+++ gcc/libcpp/directives.c
@@ -490,6 +490,8 @@ _cpp_handle_directive (cpp_reader *pfile
   else if (skip == 0)
     _cpp_backup_tokens (pfile, 1);
 
+  if (pfile->cb.end_directive)
+    pfile->cb.end_directive (pfile);
   end_directive (pfile, skip);
   if (was_parsing_args && !pfile->state.in_deferred_pragma)
     {
Index: gcc/libcpp/internal.h
===================================================================
--- gcc.orig/libcpp/internal.h
+++ gcc/libcpp/internal.h
@@ -242,6 +242,11 @@ struct _cpp_line_note
      trigraphs, '\\' an escaped newline, ' ' an escaped newline with
      intervening space, and anything else is invalid.  */
   unsigned int type;
+
+  /* file offset adjustment is recorded by add_line_note to adjust
+   * cpp_token::file_offset. The case is when some spaces are left after an
+   * escaped newline `\', cpp_token::file_offset becomes inexact. */
+  const unsigned char *adjust_offset;
 };
 
 /* Represents the contents of a file cpplib has read in.  */
