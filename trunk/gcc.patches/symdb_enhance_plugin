Index: gcc-4.6.2/gcc/plugin.def
===================================================================
--- gcc-4.6.2.orig/gcc/plugin.def	2012-04-23 09:13:04.301830324 +0800
+++ gcc-4.6.2/gcc/plugin.def	2012-05-07 13:09:11.177813560 +0800
@@ -89,6 +89,34 @@
 /* Called when a pass is first instantiated.  */
 DEFEVENT (PLUGIN_NEW_PASS)
 
+/* Called when a cpp token is extracted.  */
+DEFEVENT (PLUGIN_CPP_TOKEN)
+
+/* Called when a c token is extracted.  */
+DEFEVENT (PLUGIN_C_TOKEN)
+
+/* An extern declaration (file-scope) is encounted. */
+DEFEVENT (PLUGIN_EXTERN_DECL)
+
+/* Cooperate PLUGIN_EXTERN_FUNC to parse a function with old-style parameter
+ * declaration. */
+DEFEVENT (PLUGIN_EXTERN_FUNC_OLD_PARAM)
+
+/* Called when an extern function definition is parsed. */
+DEFEVENT (PLUGIN_EXTERN_FUNC)
+
+/* Called when an extern variable definition is parsed. */
+DEFEVENT (PLUGIN_EXTERN_VAR)
+
+/* An extern declaration specifier definition is parsed. */
+DEFEVENT (PLUGIN_EXTERN_DECLSPECS)
+
+/* A function is called. */
+DEFEVENT (PLUGIN_CALL_FUNCTION)
+
+/* Called when an enum specifier is parsed. */
+DEFEVENT (PLUGIN_ENUM_SPECIFIER)
+
 /* After the hard-coded events above, plugins can dynamically allocate events
    at run time.
    PLUGIN_EVENT_FIRST_DYNAMIC only appears as last enum element.  */
Index: gcc-4.6.2/gcc/c-family/c-lex.c
===================================================================
--- gcc-4.6.2.orig/gcc/c-family/c-lex.c	2012-04-23 09:13:04.293736840 +0800
+++ gcc-4.6.2/gcc/c-family/c-lex.c	2012-05-03 16:41:59.388911324 +0800
@@ -36,6 +36,7 @@
 #include "splay-tree.h"
 #include "debug.h"
 #include "target.h"
+#include "plugin.h"
 
 /* We may keep statistics about how long which files took to compile.  */
 static int header_time, body_time;
@@ -362,6 +363,7 @@
 	    case CPP_STRING32:
 	    case CPP_UTF8STRING:
 	      type = lex_string (tok, value, true, true);
+		  tok = NULL;
 	      break;
 
 	    case CPP_NAME:
@@ -431,6 +433,7 @@
 	{
 	  type = lex_string (tok, value, false,
 			     (lex_flags & C_LEX_STRING_NO_TRANSLATE) == 0);
+	  tok = NULL;
 	  break;
 	}
       *value = build_string (tok->val.str.len, (const char *) tok->val.str.text);
@@ -465,6 +468,7 @@
     }
 
   timevar_pop (TV_CPP);
+  invoke_plugin_callbacks (PLUGIN_CPP_TOKEN, tok);
 
   return type;
 }
Index: gcc-4.6.2/gcc/c-parser.c
===================================================================
--- gcc-4.6.2.orig/gcc/c-parser.c	2012-04-23 09:13:04.302604873 +0800
+++ gcc-4.6.2/gcc/c-parser.c	2012-05-07 13:10:08.882044806 +0800
@@ -121,45 +121,6 @@
    C++).  It would then be possible to share more of the C and C++
    lexer code, if desired.  */
 
-/* The following local token type is used.  */
-
-/* A keyword.  */
-#define CPP_KEYWORD ((enum cpp_ttype) (N_TTYPES + 1))
-
-/* More information about the type of a CPP_NAME token.  */
-typedef enum c_id_kind {
-  /* An ordinary identifier.  */
-  C_ID_ID,
-  /* An identifier declared as a typedef name.  */
-  C_ID_TYPENAME,
-  /* An identifier declared as an Objective-C class name.  */
-  C_ID_CLASSNAME,
-  /* An address space identifier.  */
-  C_ID_ADDRSPACE,
-  /* Not an identifier.  */
-  C_ID_NONE
-} c_id_kind;
-
-/* A single C token after string literal concatenation and conversion
-   of preprocessing tokens to tokens.  */
-typedef struct GTY (()) c_token {
-  /* The kind of token.  */
-  ENUM_BITFIELD (cpp_ttype) type : 8;
-  /* If this token is a CPP_NAME, this value indicates whether also
-     declared as some kind of type.  Otherwise, it is C_ID_NONE.  */
-  ENUM_BITFIELD (c_id_kind) id_kind : 8;
-  /* If this token is a keyword, this value indicates which keyword.
-     Otherwise, this value is RID_MAX.  */
-  ENUM_BITFIELD (rid) keyword : 8;
-  /* If this token is a CPP_PRAGMA, this indicates the pragma that
-     was seen.  Otherwise it is PRAGMA_NONE.  */
-  ENUM_BITFIELD (pragma_kind) pragma_kind : 8;
-  /* The location at which this token was found.  */
-  location_t location;
-  /* The value associated with this token, if any.  */
-  tree value;
-} c_token;
-
 /* A parser structure recording information about the state and
    context of parsing.  Includes lexer information with up to two
    tokens of look-ahead; more are not needed for C.  */
@@ -386,6 +347,7 @@
       break;
     }
   timevar_pop (TV_LEX);
+  invoke_plugin_callbacks (PLUGIN_C_TOKEN, token);
 }
 
 /* Return a pointer to the next token from PARSER, reading it in if
@@ -1329,6 +1291,7 @@
 	 an @interface or @protocol with prefix attributes).  We can
 	 only tell which after parsing the declaration specifiers, if
 	 any, and the first declarator.  */
+      invoke_plugin_callbacks (PLUGIN_EXTERN_DECL, NULL);
       c_parser_declaration_or_fndef (parser, true, true, true, false, true, NULL);
       break;
     }
@@ -1457,6 +1420,11 @@
       return;
     }
   finish_declspecs (specs);
+  {
+    void* pair[2]; pair[0] = specs; pair[1] = (void*) parser->tokens_avail;
+    if (!nested)
+      invoke_plugin_callbacks (PLUGIN_EXTERN_DECLSPECS, pair);
+  }
   if (c_parser_next_token_is (parser, CPP_SEMICOLON))
     {
       if (empty_ok)
@@ -1590,6 +1558,11 @@
 	{
 	  tree asm_name = NULL_TREE;
 	  tree postfix_attrs = NULL_TREE;
+	  {
+	    void* pair[2]; pair[0] = specs; pair[1] = declarator;
+        if (!nested)
+          invoke_plugin_callbacks (PLUGIN_EXTERN_VAR, pair);
+	  }
 	  if (!diagnosed_no_specs && !specs->declspecs_seen_p)
 	    {
 	      diagnosed_no_specs = true;
@@ -1709,11 +1682,15 @@
 	 declarator with a nonempty identifier list in a definition;
 	 and postfix attributes have never been accepted here in
 	 function definitions either.  */
+      if (!nested)
+        invoke_plugin_callbacks (PLUGIN_EXTERN_FUNC_OLD_PARAM, NULL);
       while (c_parser_next_token_is_not (parser, CPP_EOF)
 	     && c_parser_next_token_is_not (parser, CPP_OPEN_BRACE))
 	c_parser_declaration_or_fndef (parser, false, false, false,
 				       true, false, NULL);
       store_parm_decls ();
+      if (!nested)
+        invoke_plugin_callbacks (PLUGIN_EXTERN_FUNC, declarator);
       DECL_STRUCT_FUNCTION (current_function_decl)->function_start_locus
 	= c_parser_peek_token (parser)->location;
       fnbody = c_parser_compound_statement (parser);
@@ -2211,6 +2188,7 @@
 	    }
 	  token = c_parser_peek_token (parser);
 	  enum_id = token->value;
+      invoke_plugin_callbacks (PLUGIN_ENUM_SPECIFIER, enum_id);
 	  /* Set the location in case we create a decl now.  */
 	  c_parser_set_source_position_from_token (token);
 	  decl_loc = value_loc = token->location;
@@ -6563,6 +6541,7 @@
 	  break;
 	case CPP_OPEN_PAREN:
 	  /* Function call.  */
+      invoke_plugin_callbacks (PLUGIN_CALL_FUNCTION, expr.value);
 	  c_parser_consume_token (parser);
 	  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
 	    exprlist = NULL;
Index: gcc-4.6.2/gcc/plugin.c
===================================================================
--- gcc-4.6.2.orig/gcc/plugin.c	2012-04-23 09:13:04.300629221 +0800
+++ gcc-4.6.2/gcc/plugin.c	2012-05-07 13:09:48.486780120 +0800
@@ -438,6 +438,15 @@
       case PLUGIN_EARLY_GIMPLE_PASSES_START:
       case PLUGIN_EARLY_GIMPLE_PASSES_END:
       case PLUGIN_NEW_PASS:
+      case PLUGIN_CPP_TOKEN:
+      case PLUGIN_C_TOKEN:
+      case PLUGIN_EXTERN_DECL:
+      case PLUGIN_EXTERN_FUNC_OLD_PARAM:
+      case PLUGIN_EXTERN_FUNC:
+      case PLUGIN_EXTERN_VAR:
+      case PLUGIN_EXTERN_DECLSPECS:
+      case PLUGIN_CALL_FUNCTION:
+      case PLUGIN_ENUM_SPECIFIER:
         {
           struct callback_info *new_callback;
           if (!callback)
@@ -514,6 +523,15 @@
       case PLUGIN_EARLY_GIMPLE_PASSES_START:
       case PLUGIN_EARLY_GIMPLE_PASSES_END:
       case PLUGIN_NEW_PASS:
+      case PLUGIN_CPP_TOKEN:
+      case PLUGIN_C_TOKEN:
+      case PLUGIN_EXTERN_DECL:
+      case PLUGIN_EXTERN_FUNC_OLD_PARAM:
+      case PLUGIN_EXTERN_FUNC:
+      case PLUGIN_EXTERN_VAR:
+      case PLUGIN_EXTERN_DECLSPECS:
+      case PLUGIN_CALL_FUNCTION:
+      case PLUGIN_ENUM_SPECIFIER:
         {
           /* Iterate over every callback registered with this event and
              call it.  */
Index: gcc-4.6.2/gcc/doc/plugins.texi
===================================================================
--- gcc-4.6.2.orig/gcc/doc/plugins.texi	2012-04-23 09:13:04.300629221 +0800
+++ gcc-4.6.2/gcc/doc/plugins.texi	2012-05-07 13:08:14.087944170 +0800
@@ -183,6 +183,23 @@
   PLUGIN_EARLY_GIMPLE_PASSES_END,
   /* Called when a pass is first instantiated.  */
   PLUGIN_NEW_PASS,
+  PLUGIN_CPP_TOKEN,                /* Called when GCC gets a cpp token. */
+  PLUGIN_C_TOKEN,                  /* Called when GCC gets a c token. */
+  /* An extern declaration (file-scope) is encounted. */
+  PLUGIN_EXTERN_DECL,
+  /* Cooperate PLUGIN_EXTERN_FUNC to parse a function with old-style parameter
+   * declaration. */
+  PLUGIN_EXTERN_FUNC_OLD_PARAM,
+  /* An extern function definition is parsed. */
+  PLUGIN_EXTERN_FUNC,
+  /* An extern variable definition is parsed. */
+  PLUGIN_EXTERN_VAR,
+  /* An extern declaration specifier definition is parsed. */
+  PLUGIN_EXTERN_DECLSPECS,
+  /* A function is called. */
+  PLUGIN_CALL_FUNCTION,
+  /* An enum specifier is parsed. */
+  PLUGIN_ENUM_SPECIFIER,
 
   PLUGIN_EVENT_FIRST_DYNAMIC    /* Dummy event used for indexing callback
                                    array.  */
Index: gcc-4.6.2/gcc/c-family/c-common.h
===================================================================
--- gcc-4.6.2.orig/gcc/c-family/c-common.h	2012-04-23 09:13:04.293736840 +0800
+++ gcc-4.6.2/gcc/c-family/c-common.h	2012-04-23 09:13:57.672983344 +0800
@@ -25,6 +25,7 @@
 #include "splay-tree.h"
 #include "cpplib.h"
 #include "ggc.h"
+#include "c-pragma.h"
 
 /* In order for the format checking to accept the C frontend
    diagnostic framework extensions, you must include this file before
@@ -1007,4 +1008,43 @@
 extern tree c_omp_remap_decl (tree, bool);
 extern void record_types_used_by_current_var_decl (tree);
 
+/* The following local token type is used.  */
+
+/* A keyword.  */
+#define CPP_KEYWORD ((enum cpp_ttype) (N_TTYPES + 1))
+
+/* More information about the type of a CPP_NAME token.  */
+typedef enum c_id_kind {
+  /* An ordinary identifier.  */
+  C_ID_ID,
+  /* An identifier declared as a typedef name.  */
+  C_ID_TYPENAME,
+  /* An identifier declared as an Objective-C class name.  */
+  C_ID_CLASSNAME,
+  /* An address space identifier.  */
+  C_ID_ADDRSPACE,
+  /* Not an identifier.  */
+  C_ID_NONE
+} c_id_kind;
+
+/* A single C token after string literal concatenation and conversion
+   of preprocessing tokens to tokens.  */
+typedef struct GTY (()) c_token {
+  /* The kind of token.  */
+  ENUM_BITFIELD (cpp_ttype) type : 8;
+  /* If this token is a CPP_NAME, this value indicates whether also
+     declared as some kind of type.  Otherwise, it is C_ID_NONE.  */
+  ENUM_BITFIELD (c_id_kind) id_kind : 8;
+  /* If this token is a keyword, this value indicates which keyword.
+     Otherwise, this value is RID_MAX.  */
+  ENUM_BITFIELD (rid) keyword : 8;
+  /* If this token is a CPP_PRAGMA, this indicates the pragma that
+     was seen.  Otherwise it is PRAGMA_NONE.  */
+  ENUM_BITFIELD (pragma_kind) pragma_kind : 8;
+  /* The value associated with this token, if any.  */
+  tree value;
+  /* The location at which this token was found.  */
+  location_t location;
+} c_token;
+
 #endif /* ! GCC_C_COMMON_H */
