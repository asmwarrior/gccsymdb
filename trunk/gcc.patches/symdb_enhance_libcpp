Index: gcc/libcpp/include/cpplib.h
===================================================================
--- gcc.orig/libcpp/include/cpplib.h
+++ gcc/libcpp/include/cpplib.h
@@ -493,6 +493,22 @@ struct cpp_callbacks
      be expanded.  */
   cpp_hashnode * (*macro_to_expand) (cpp_reader *, const cpp_token *);
 
+  /* The more powerful function extracts token than cpp_get_token. Later
+   * callbacks show it. */
+  void (*lex_token) (cpp_reader *, const cpp_token*);
+  /* The pair is called when gcc expands macro. Enable lex_token in
+   * macro_start_expand, you can catch all macro tokens. The pair can be called
+   * nested. */
+  void (*macro_start_expand) (cpp_reader *, const cpp_token *,
+		  const cpp_hashnode *);
+  void (*macro_end_expand) (cpp_reader *, bool);
+  /* The pair is called when cpp directive (starting from `#', such as
+   * `#define M', `#endif' etc) is encountered and reaches end. When enable
+   * lex_token in start_directive, the sequence is lex_token("define"),
+   * lex_token("M") ... */
+  void (*start_directive) (cpp_reader *);
+  void (*end_directive) (cpp_reader *);
+
   /* Called to emit a diagnostic.  This callback receives the
      translated message.  */
   bool (*error) (cpp_reader *, int, int, source_location, unsigned int,
Index: gcc/libcpp/lex.c
===================================================================
--- gcc.orig/libcpp/lex.c
+++ gcc/libcpp/lex.c
@@ -1827,6 +1827,8 @@ _cpp_lex_token (cpp_reader *pfile)
 	}
       else
 	result = _cpp_lex_direct (pfile);
+    if (pfile->cb.lex_token)
+      pfile->cb.lex_token (pfile, result);
 
       if (result->flags & BOL)
 	{
Index: gcc/libcpp/macro.c
===================================================================
--- gcc.orig/libcpp/macro.c
+++ gcc/libcpp/macro.c
@@ -58,7 +58,7 @@ static bool paste_tokens (cpp_reader *, 
 static void replace_args (cpp_reader *, cpp_hashnode *, cpp_macro *,
 			  macro_arg *);
 static _cpp_buff *funlike_invocation_p (cpp_reader *, cpp_hashnode *,
-					_cpp_buff **);
+					_cpp_buff **, const cpp_token *);
 static bool create_iso_definition (cpp_reader *, cpp_macro *);
 
 /* #define directive parsing and handling.  */
@@ -768,7 +768,7 @@ collect_args (cpp_reader *pfile, const c
    argument is the same as in collect_args.  */
 static _cpp_buff *
 funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node,
-		      _cpp_buff **pragma_buff)
+		      _cpp_buff **pragma_buff, const cpp_token* head)
 {
   const cpp_token *token, *padding = NULL;
 
@@ -785,6 +785,8 @@ funlike_invocation_p (cpp_reader *pfile,
   if (token->type == CPP_OPEN_PAREN)
     {
       pfile->state.parsing_args = 2;
+      if (pfile->cb.macro_start_expand)
+        pfile->cb.macro_start_expand (pfile, head, node);
       return collect_args (pfile, node, pragma_buff);
     }
 
@@ -830,6 +832,8 @@ enter_macro_context (cpp_reader *pfile, 
   /* The presence of a macro invalidates a file's controlling macro.  */
   pfile->mi_valid = false;
 
+  pfile->about_to_expand_macro_p = true;
+
   pfile->state.angled_headers = false;
 
   if ((node->flags & NODE_BUILTIN) && !(node->flags & NODE_USED))
@@ -854,7 +858,7 @@ enter_macro_context (cpp_reader *pfile, 
 	  pfile->state.prevent_expansion++;
 	  pfile->keep_tokens++;
 	  pfile->state.parsing_args = 1;
-	  buff = funlike_invocation_p (pfile, node, &pragma_buff);
+	  buff = funlike_invocation_p (pfile, node, &pragma_buff, result);
 	  pfile->state.parsing_args = 0;
 	  pfile->keep_tokens--;
 	  pfile->state.prevent_expansion--;
@@ -869,6 +873,7 @@ enter_macro_context (cpp_reader *pfile, 
 	      if (pragma_buff)
 		_cpp_release_buff (pfile, pragma_buff);
 
+	      pfile->about_to_expand_macro_p = false;
 	      return 0;
 	    }
 
@@ -893,8 +898,12 @@ enter_macro_context (cpp_reader *pfile, 
       macro->used = 1;
 
       if (macro->paramc == 0)
-	_cpp_push_token_context (pfile, node, macro->exp.tokens,
+	{
+      if (pfile->cb.macro_start_expand)
+        pfile->cb.macro_start_expand (pfile, result, node);
+	  _cpp_push_token_context (pfile, node, macro->exp.tokens,
 				 macro_real_token_count (macro));
+	}
 
       if (pragma_buff)
 	{
@@ -912,12 +921,15 @@ enter_macro_context (cpp_reader *pfile, 
 	      pragma_buff = tail;
 	    }
 	  while (pragma_buff != NULL);
+	  pfile->about_to_expand_macro_p = false;
 	  return 2;
 	}
 
+	  pfile->about_to_expand_macro_p = false;
       return 1;
     }
 
+  pfile->about_to_expand_macro_p = false;
   /* Handle built-in macros and the _Pragma operator.  */
   return builtin_macro (pfile, node);
 }
@@ -1195,6 +1207,18 @@ expand_arg (cpp_reader *pfile, macro_arg
   CPP_WTRADITIONAL (pfile) = saved_warn_trad;
 }
 
+/* Return TRUE iff we are expanding a macro or are about to start
+   expanding one. */
+static bool
+in_macro_expansion_p (cpp_reader *pfile)
+{
+  if (pfile == NULL)
+    return false;
+
+  return (pfile->about_to_expand_macro_p
+      || pfile->context->macro);
+}
+
 /* Pop the current context off the stack, re-enabling the macro if the
    context represented a macro's replacement list.  The context
    structure is not freed so that we can re-use it later.  */
@@ -1210,6 +1234,9 @@ _cpp_pop_context (cpp_reader *pfile)
     _cpp_release_buff (pfile, context->buff);
 
   pfile->context = context->prev;
+
+  if (pfile->cb.macro_end_expand)
+    pfile->cb.macro_end_expand (pfile, in_macro_expansion_p (pfile));
 }
 
 /* External routine to get a token.  Also used nearly everywhere
@@ -1228,6 +1255,7 @@ cpp_get_token (cpp_reader *pfile)
 {
   const cpp_token *result;
   bool can_set = pfile->set_invocation_location;
+  bool saved_about_to_expand_macro_p = pfile->about_to_expand_macro_p;
   pfile->set_invocation_location = false;
 
   for (;;)
@@ -1250,7 +1278,8 @@ cpp_get_token (cpp_reader *pfile)
 	      paste_all_tokens (pfile, result);
 	      if (pfile->state.in_directive)
 		continue;
-	      return padding_token (pfile, result);
+	      result = padding_token (pfile, result);
+	      goto out;
 	    }
 	}
       else
@@ -1258,7 +1287,8 @@ cpp_get_token (cpp_reader *pfile)
 	  _cpp_pop_context (pfile);
 	  if (pfile->state.in_directive)
 	    continue;
-	  return &pfile->avoid_paste;
+	  result = &pfile->avoid_paste;
+	  goto out;
 	}
 
       if (pfile->state.in_directive && result->type == CPP_COMMENT)
@@ -1317,7 +1347,8 @@ cpp_get_token (cpp_reader *pfile)
  	    {
 	      if (pfile->state.in_directive || ret == 2)
 		continue;
-	      return padding_token (pfile, result);
+	      result = padding_token (pfile, result);
+	      goto out;
 	    }
 	}
       else
@@ -1334,6 +1365,8 @@ cpp_get_token (cpp_reader *pfile)
       break;
     }
 
+out:
+  pfile->about_to_expand_macro_p = saved_about_to_expand_macro_p;
   return result;
 }
 
Index: gcc/libcpp/directives.c
===================================================================
--- gcc.orig/libcpp/directives.c
+++ gcc/libcpp/directives.c
@@ -275,6 +275,9 @@ start_directive (cpp_reader *pfile)
 
   /* Some handlers need the position of the # for diagnostics.  */
   pfile->directive_line = pfile->line_table->highest_line;
+
+  if (pfile->cb.start_directive)
+    pfile->cb.start_directive (pfile);
 }
 
 /* Called when leaving a directive, _Pragma or command-line directive.  */
@@ -309,6 +312,9 @@ end_directive (cpp_reader *pfile, int sk
   pfile->state.in_expression = 0;
   pfile->state.angled_headers = 0;
   pfile->directive = 0;
+
+  if (pfile->cb.end_directive)
+    pfile->cb.end_directive (pfile);
 }
 
 /* Prepare to handle the directive in pfile->directive.  */
Index: gcc/libcpp/internal.h
===================================================================
--- gcc.orig/libcpp/internal.h
+++ gcc/libcpp/internal.h
@@ -370,6 +370,13 @@ struct cpp_reader
      macro invocation.  */
   source_location invocation_location;
 
+  /* Nonzero if we are about to expand a macro.  Note that if we are
+     really expanding a macro, cpp_context::macro returns the macro being
+     expanded and this flag is set to false.  Client code should use the
+     function in_macro_expansion_p to know if we are either about to expand a
+     macro, or are actually expanding one.  */
+  bool about_to_expand_macro_p;
+
   /* True if this call to cpp_get_token should consider setting
      invocation_location.  */
   bool set_invocation_location;
